---
layout: post
title: "개념과 알고리즘"
---

## 05. 비트 조작

### 산술 우측 시프트 vs. 논리 우측 시프트

### 기본적인 비트 조작

#### 비트값 확인

```java
boolean getBit(int num, int i) {
    return ((num & (1 << i)) != 0);
}
```

#### 비트값 채워넣기

```java
boolean setBit(int num, int i) {
    return num | (1 << i);
}
```

#### 비트값 삭제하기

```java
boolean clearBit(int num, int i) {
    int mask = ~(1 << i);
    return num & mask;
}
```

#### 비트값 바꾸기

```java
boolean updateBit(int num, int i, boolean bitIs1) {
    int value = bitIs1 ? 1 l : 0;
    int mask = ~(1 << i);
    return (num & mask) | (value << i);
}
```

## 06. 수학 및 논리 퍼즐

## 07. 객체 지향 설계

### 접근법

#### 단계 #1: 모호성의 해소
#### 단계 #2: 핵심 객체의 설계
#### 단계 #3: 관계 분석
#### 단계 #4: 행동 분석

### 디자인 패턴

#### 싱글톤 클래스(singleton class)

```java
public class Restaurant {
    private static Restaurant instance;
    protected Restaurant() {}
    public static Restaurant getInstance() {
        if (instance == null) {
            instance = new Restaurant();
        }
        return instance;
    }
}
```

#### 팩터리 메서드(factory method)

```java
public class CardGame {
    public static CardGame createCardGame(GameType type) {
        if (type == GameType.Poker) {
            return new PockerGame();
        } else if (type == GameType.BlackJack) {
            return new BlackJackGame();
        }
        return null;
    }
}
```

## 08. 재귀와 동적 프로그래밍

* "n번째 ... 를 계산하는 알고리즘을 설계하라"
* "첫 n개를 나열하는 코드를 작성하라"
* "모든 ...을 계산하는 메서드를 구현하라"


### Approach

#### 상향식 접근법(bottom-up approach)
#### 하향식 접근법(top-down approach)
#### 반반 접근법(half-and-half approach)

### 재귀적(recursive) 해법 vs. 순환적(iterative) 해법

### 동적계획법 & Memoization

#### Fibonacci number

* 재귀

```java
int fibonacci(int i) {
    if (i == 0) return 0;
    if (i == 1) return 1;
    return fibonacci(i - 1) + fibonacci(i - 2);
}
```

Tip: 재귀 호출을 트리로 그려 보는 것은 재귀적 알고리즘의 수행 시간을 알아내는 데 굉장히 효과적이다.

* 하향식 동적 프로그래밍(메모이제이션)

```java
int fibonacci(int n) {
    return fibonacci(n, new int[n + 1]);
}

int fibonacci(int i, int[] memo) {
    if (i == 0 || i = 1) return i;
    if (memo[i] == 0) {
        memo[i] = fibonacci(i - 1, memo) + fibonacci(i - 2, memo);
    }
    return memo[i]; 
}
```

* 상향식 동적 프로그래밍

```java
int fibonacci(int n) {
    if (n == 0 || n = 1) return n;
    int[] memo = new int[n];
    memo[0] = 0;
    memo[1] = 1;
    for (int i = 2; i < n; i++) {
        memo[i] = memo[i - 1] + memo[i - 2];
    }
    return memo[n - 1] + memo[n - 2]; 
}
```

## 09. 시스템 설계 및 규모 확장성(Scalability)

### 문제를 다루는 방법

### 시스템 설계: 단계별 접근법

### 규모 확장을 위한 알고리즘: 단계별 접근법

### 시스템 설계의 핵심 개념

#### horizontal scaling vs vertical scaling 
#### load balancer 
#### denormalization & NoSQL
#### sharding
* vertical partitioning
* key/hash partitioning 
  + mod(key,n)
* directory partitioning 
  + lookup table -> single point of failure

#### Caching
#### 비동기식 처리 & 큐
#### 네트워크 성능 척도
#### MapReduce

### 시스템 설계 시 고려할 점
* Failures
* Availability & Reliability
* 읽기 중심 vs. 쓰기 중심
* Security
